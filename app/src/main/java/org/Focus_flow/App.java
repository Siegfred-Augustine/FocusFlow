/*
 * This source file was generated by the Gradle 'init' task
 */
package org.Focus_flow;

import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Platform;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.ptr.IntByReference;


import javax.swing.*;
import java.io.*;
import java.time.LocalDateTime;
import java.util.*;
import java.util.Timer;
import javax.swing.JOptionPane;


public class App {
        // Interface for Windows API calls
    public interface User32 extends Library {
        User32 INSTANCE = Native.load("user32", User32.class);
        HWND GetForegroundWindow();
        int GetWindowThreadProcessId(HWND hWnd, IntByReference processId);
        int GetWindowTextW(HWND hWnd, char[] lpString, int nMaxCount);
    }

    // Interface for Process API calls
    public interface Kernel32 extends Library {
        Kernel32 INSTANCE = Native.load("kernel32", Kernel32.class);
        boolean QueryFullProcessImageNameW(int hProcess, int dwFlags, char[] lpExeName, IntByReference lpdwSize);
        int OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);
        void CloseHandle(int handle);
    }

    private static final int PROCESS_QUERY_LIMITED_INFORMATION = 0x1000;
    private static final Map<String, Long> appScreenTime = new HashMap<>();
    private static String lastActiveApp = "";
    private static long lastUpdateTime = System.currentTimeMillis();
    private static int screenTime;

    private static String fileName = generateFileName();

    //private static int totalMins, totalHours, hoursTilNotify = 5;


    public static void main(String[] args) {
        if (!Platform.isWindows()) {
            System.err.println("This program only works on Windows.");
            return;
        }
        aggregateScreentime();
        try {
            while (true) {
                updateScreenTime();
                Thread.sleep(1000); // Update every second

                // Save to file every 5 minutes
                if (System.currentTimeMillis() - lastUpdateTime >= 10000) {
                    checkAndUpdateFileName();
                    saveToCSV();
                    
                    lastUpdateTime = System.currentTimeMillis();

                    //addScreenTime("screentime.txt");
                    //screenTime = totalMins + (60 * totalHours);
                    //notifyTask();

                    //System.out.println("current total time - " + screenTime);
                    //Task.deadLineChecker();

                }
            }
        } catch (InterruptedException e) {
            System.err.println("Tracking interrupted: " + e.getMessage());
            saveToCSV(); // Save final data before exiting
        } catch (Exception e) {
            System.err.println("Unexpected error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void aggregateScreentime(){
        Map<String, Long> csvData = Time.readCSV(fileName);
        if (csvData == null) {
            csvData = new HashMap<>(); // Default to an empty map
        }

        // Merge the data from the CSV into the existing appScreenTime map
        csvData.forEach((appName, totalTime) -> 
            appScreenTime.merge(appName, totalTime, Long::sum)
        );
        System.out.println(appScreenTime);
    }

    private static String generateFileName() {
        // Generate file name with today's date
        String date = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        return "screentime_" + date + ".csv";
    }

    private static void checkAndUpdateFileName() {
        // Get the current date and update fileName if it doesn't match
        String currentDate = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        if (!fileName.contains(currentDate)) {
            fileName = generateFileName();
            System.out.println("Updated file name to: " + fileName);
        }
    }

    private static void updateScreenTime() {
        try {
            HWND foregroundWindow = User32.INSTANCE.GetForegroundWindow();
            if (foregroundWindow == null) {
                return;
            }

            IntByReference processId = new IntByReference();
            User32.INSTANCE.GetWindowThreadProcessId(foregroundWindow, processId);

            int process = Kernel32.INSTANCE.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, processId.getValue());
            if (process == 0) {
                return;
            }

            try {
                char[] filename = new char[512];
                IntByReference size = new IntByReference(512);
                if (Kernel32.INSTANCE.QueryFullProcessImageNameW(process, 0, filename, size)) {
                    String processName = new String(filename, 0, size.getValue()).trim();

                    if (!processName.isEmpty()) {
                        String appName = processName.substring(processName.lastIndexOf('\\') + 1);
                        if (!appName.equals(lastActiveApp)) {
                            // Update screen time for the app
                            appScreenTime.merge(appName, 1L, Long::sum);
                            lastActiveApp = appName;
                        } else {
                            // Increment time for current app
                            appScreenTime.merge(appName, 1L, Long::sum);
                        }
                    }
                }
            } finally {
                Kernel32.INSTANCE.CloseHandle(process);
            }
        } catch (Exception e) {
            System.err.println("Error updating screen time: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void saveToCSV() {
        try (FileWriter writer = new FileWriter(fileName)) {
            // Write header
            writer.write("App Name,Hours,Minutes,Seconds\n");

            // Sort apps by screen time
            List<Map.Entry<String, Long>> sortedApps = new ArrayList<>(appScreenTime.entrySet());
            sortedApps.sort(Map.Entry.<String, Long>comparingByValue().reversed());

            // Write app data
            for (Map.Entry<String, Long> entry : sortedApps) {
                String appName = entry.getKey();
                long seconds = entry.getValue();
                long minutes = seconds / 60;
                long hours = minutes / 60;
                minutes %= 60;
                seconds %= 60;

                System.out.println(Long.toString(seconds));

                writer.write(String.format("%s,%d,%d,%d\n", appName, hours, minutes, seconds));
            }

            System.out.println("Screen time data saved to: " + fileName);
        } catch (IOException e) {
            System.err.println("Error saving to CSV: " + e.getMessage());

        }
    }
    /* 
    public static void addScreenTime(String filepath){
        File filename = new File(filepath);
        String line, timePart;
        totalMins = 0;
        totalHours = 0;
        try(Scanner scan = new Scanner(filename)){
            while(scan.hasNextLine()){
                //scan.nextLine();
                //scan.nextLine();
                line = scan.nextLine();
                System.out.println(line);

                int colonIndex = line.indexOf(':');
                timePart = line.substring(colonIndex + 2);
                line = timePart.replace(" hours,", "").replace(" minutes", "").trim();

                String[] strippedTime = line.split(" ");
                totalMins += Integer.parseInt(strippedTime[1]);
                totalHours += Integer.parseInt(strippedTime[0]);

                totalHours += totalMins / 60;
                totalMins %= 60;
                System.out.println(totalMins);
            }
        }catch(IOException e){
            e.printStackTrace();

        }
    }
    public static void notifyTask(){
        if(totalHours>hoursTilNotify && !Task.taskList.isEmpty()){
            JOptionPane.showMessageDialog(null,"You still have tasks left to do!!", "Ongoing Tasks!", JOptionPane.WARNING_MESSAGE);
        }
    }
        */
}



