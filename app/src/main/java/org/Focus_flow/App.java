/*
 * This source file was generated by the Gradle 'init' task
 */
package org.Focus_flow;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Platform;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.ptr.IntByReference;

import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class App {
        // Interface for Windows API calls
    public interface User32 extends Library {
        User32 INSTANCE = Native.load("user32", User32.class);
        HWND GetForegroundWindow();
        int GetWindowThreadProcessId(HWND hWnd, IntByReference processId);
        int GetWindowTextW(HWND hWnd, char[] lpString, int nMaxCount);
    }

    // Interface for Process API calls
    public interface Kernel32 extends Library {
        Kernel32 INSTANCE = Native.load("kernel32", Kernel32.class);
        boolean QueryFullProcessImageNameW(int hProcess, int dwFlags, char[] lpExeName, IntByReference lpdwSize);
        int OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);
        void CloseHandle(int handle);
    }

    private static final int PROCESS_QUERY_LIMITED_INFORMATION = 0x1000;
    private static final Map<String, Long> appScreenTime = new HashMap<>();
    private static String lastActiveApp = "";
    private static long lastUpdateTime = System.currentTimeMillis();
    private static int screenTime;
    private static int totalMins, totalHours, hoursTilNotify = 5;

    public static void main(String[] args) {
        if (!Platform.isWindows()) {
            System.err.println("This program only works on Windows.");
            return;
        }

        try {
            while (true) {
                updateScreenTime();
                Thread.sleep(1000); // Update every second

                // Save to file every 5 minutes
                if (System.currentTimeMillis() - lastUpdateTime >= 10000) {
                    saveToFile();
                    lastUpdateTime = System.currentTimeMillis();

                    addScreenTime("screentime.txt");
                    screenTime = totalMins + (60 * totalHours);
                    notifyTask();
                    System.out.println("current total time - " + screenTime);
                }
            }
        } catch (InterruptedException e) {
            System.err.println("Tracking interrupted: " + e.getMessage());
            saveToFile(); // Save final data before exiting
        } catch (Exception e) {
            System.err.println("Unexpected error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void updateScreenTime() {
        try {
            HWND foregroundWindow = User32.INSTANCE.GetForegroundWindow();
            if (foregroundWindow == null) {
                return;
            }

            IntByReference processId = new IntByReference();
            User32.INSTANCE.GetWindowThreadProcessId(foregroundWindow, processId);

            int process = Kernel32.INSTANCE.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, processId.getValue());
            if (process == 0) {
                return;
            }

            try {
                char[] filename = new char[512];
                IntByReference size = new IntByReference(512);
                if (Kernel32.INSTANCE.QueryFullProcessImageNameW(process, 0, filename, size)) {
                    String processName = new String(filename, 0, size.getValue()).trim();

                    if (!processName.isEmpty()) {
                        String appName = processName.substring(processName.lastIndexOf('\\') + 1);
                        if (!appName.equals(lastActiveApp)) {
                            // Update screen time for the app
                            appScreenTime.merge(appName, 1L, Long::sum);
                            lastActiveApp = appName;
                        } else {
                            // Increment time for current app
                            appScreenTime.merge(appName, 1L, Long::sum);
                        }
                    }
                }
            } finally {
                Kernel32.INSTANCE.CloseHandle(process);
            }
        } catch (Exception e) {
            System.err.println("Error updating screen time: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void saveToFile(){
        String fileName = "screentime.txt";
        //LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".txt";

        try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) {
            //writer.println("Screen Time Report - " + LocalDateTime.now());
            //writer.println("----------------------------------------");

            // Sort apps by screen time
            List<Map.Entry<String, Long>> sortedApps = new ArrayList<>(appScreenTime.entrySet());
            sortedApps.sort(Map.Entry.<String, Long>comparingByValue().reversed());

            for (Map.Entry<String, Long> entry : sortedApps) {
                String appName = entry.getKey();
                long seconds = entry.getValue();
                long minutes = seconds / 60;
                long hours = minutes / 60;
                minutes %= 60;

                writer.printf("%s: %02d hours, %02d minutes%n", appName, hours, minutes);
            }

            System.out.println("Screen time data saved to: " + fileName);
        } catch (IOException e) {
            System.err.println("Error saving to file: " + e.getMessage());
        }
    }
    public static void addScreenTime(String filepath){
        File filename = new File(filepath);
        String line, timePart;
        totalMins = 0;
        totalHours = 0;
        try(Scanner scan = new Scanner(filename)){
            while(scan.hasNextLine()){
                //scan.nextLine();
                //scan.nextLine();
                line = scan.nextLine();
                System.out.println(line);

                int colonIndex = line.indexOf(':');
                timePart = line.substring(colonIndex + 2);
                line = timePart.replace(" hours,", "").replace(" minutes", "").trim();

                String[] strippedTime = line.split(" ");
                totalMins += Integer.parseInt(strippedTime[1]);
                totalHours += Integer.parseInt(strippedTime[0]);

                totalHours += totalMins / 60;
                totalMins %= 60;
                System.out.println(totalMins);
            }
        }catch(IOException e){
            e.printStackTrace();
        }
    }
    public static void notifyTask(){
        if(totalHours>hoursTilNotify && !Task.taskList.isEmpty()){
            System.out.println("You still have tasks");//temporary
        }
    }
}

